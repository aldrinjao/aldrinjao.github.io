<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>BARMM CA incidents - Deaths</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v2.2.0/mapbox-gl.css"
      rel="stylesheet"
    />
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.2.0/mapbox-gl.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.3.0/turf.min.js"></script>
    <link href="./distribute/nouislider.css" rel="stylesheet" />
    <script src="./distribute/nouislider.js"></script>
    <link href="./multiselect/styles/multiselect.css" rel="stylesheet" />
    <script src="./multiselect/multiselect.min.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
    </style>
  </head>

  <body>
    <style>
      .map-overlay {
        font: 12px/20px "Helvetica Neue", Arial, Helvetica, sans-serif;
        position: absolute;
        min-width: 300px;
        top: 0;
        left: 0;
        padding: 10px;
      }

      .map-overlay .map-overlay-inner {
        background-color: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        padding: 10px;
        margin-bottom: 10px;
        padding-bottom: 15px;
      }

      .map-overlay h2 {
        line-height: 24px;
        display: block;
        margin: 0 0 10px;
      }

      .map-overlay .legend .bar {
        height: 10px;
        width: 100%;
        background: linear-gradient(to right, #fee5d9, #a50f15);
      }

      .map-overlay.sliderclass {
        background-color: transparent;
        display: inline-block;
        position: relative;
        margin: 0;
        cursor: ew-resize;
      }

      .legendbox {
        width: 12px;
        height: 12px;
        border: 1px solid rgb(58, 58, 58);
        margin: 0px 10px;
      }

      .legendrow {
        display: flex;
        flex-direction: row;
        justify-content: start;
        align-items: center;
      }


      .multiselect-wrapper .multiselect-input {
        width: 90%;
      }
    </style>

    <div id="map"></div>

    <div class="map-overlay top">
      <div class="map-overlay-inner">
        <h2>Year: <label id="year"> 2011 - 2020</label></h2>

        <!-- <input id="slider" class='sliderclass' style="width: 100%;cursor: ew-resize;" type="range" min="0" max="8"
                step="1" value="0"> -->

        <div id="slider2" style="width: 90%; margin: auto"></div>
        <div style="margin-top: 20px">
          <h2>Months</h2>

          <select id="monthSelect" multiple>
            <option value="1">January</option>
            <option value="2">February</option>
            <option value="3">March</option>
            <option value="4">April</option>
            <option value="5">May</option>
            <option value="6">June</option>
            <option value="7">July</option>
            <option value="8">August</option>
            <option value="9">September</option>
            <option value="10">October</option>
            <option value="11">November</option>
            <option value="12">December</option>
          </select>
        </div>
      </div>
    </div>

    <div class="map-overlay" style="top: 180px">
      <div class="map-overlay-inner">
        <h2>Layer Control</h2>

        <div class="legendrow">
          <input type="checkbox" id="opt1" name="opt1" value="opt1" checked />
          <label for="opt1"> Points</label>
        </div>
        <div class="legendrow">
          <input type="checkbox" id="opt2" name="opt2" value="opt2" checked />
          <label for="opt2"> Clusters</label>
        </div>

        <div class="legendrow" style="display: none">
          <input type="checkbox" id="opt3" name="opt3" value="opt3" />
          <label for="opt3"> Choropleth</label>
        </div>
      </div>
    </div>

    <div class="map-overlay" style="top: 300px; min-width: 200px">
      <div class="map-overlay-inner left">
        <div class="cbox-left">
          <h2>Deaths</h2>
          Cluster Color
          <div class="legendrow">
            <input type="checkbox" id="cat1" name="cat1" value="cat1" checked />
            <div class="legendbox" style="background-color: #ff0000"></div>
            <span>Deaths</span>
          </div>



    </div>

    <div class="map-overlay" style="top: 480px; display: none">
      <div class="map-overlay-inner">
        <div id="legend" class="legend">
          <h2>Incident Count</h2>
          Polygon Fill
          <div class="legendrow">
            <div class="legendbox" style="background-color: #eeeeee"></div>
            <span style="margin-left: 10px">No Data</span>
          </div>
          <div class="legendrow">
            <div class="legendbox" style="background-color: #fcbba1"></div>
            <span style="margin-left: 10px">1 - 500</span>
          </div>

          <div class="legendrow">
            <div class="legendbox" style="background-color: #fc9272"></div>
            <span style="margin-left: 10px">500 - 1000</span>
          </div>

          <div class="legendrow">
            <div class="legendbox" style="background-color: #fb6a4a"></div>
            <span style="margin-left: 10px">1000 - 5000</span>
          </div>

          <div class="legendrow">
            <div class="legendbox" style="background-color: #de2d26"></div>
            <span style="margin-left: 10px">5000 - 10000</span>
          </div>

          <div class="legendrow">
            <div class="legendbox" style="background-color: #a50f15"></div>
            <span style="margin-left: 10px">Above 10000</span>
          </div>
        </div>
      </div>
    </div>

    <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="./codes.js" charset="utf-8"></script>

    <script>
      var CATEGORIES = 1;
      var START_YEAR = 2011;
      var END_YEAR = 2020;

      const queryString = window.location.search;
      const defaultZoomDisplay = new URLSearchParams(queryString).get("zoom");
      var CLUSTERZOOMTHRESHOLD = 9;
      if (defaultZoomDisplay == "munc") {
        CLUSTERZOOMTHRESHOLD = 6;
      }

      var slider2 = document.getElementById("slider2");
      document.multiselect("#monthSelect");
      document.multiselect("#monthSelect").selectAll();

      noUiSlider.create(slider2, {
        start: [0, END_YEAR - START_YEAR],
        step: 1,
        connect: true,
        range: {
          min: 0,
          max: END_YEAR - START_YEAR,
        },
      });

      mapboxgl.accessToken =
        "pk.eyJ1IjoiY29uZmxpY3RhbGVydCIsImEiOiJja253c3p2Z3AwZ2JxMm5xZHZibTk2cHkzIn0.j29K1BrZjO-gnWDYHE0kiA";
      var map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/conflictalert/cknxzmh1y023r17mphj1p8ng5",
        center: [122, 7],
        zoom: 7,
        minZoom: 7,
        maxZoom: 12,
      });

      var zoomThreshold = 9;
      var years = [2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020];

      var munc_code = JSON.parse(
        Get("https://crc2022-dev.online/maps/munc_code.json")
      );



      var incidentPointsLayer = {
        id: "incpoints",
        type: "circle",
        source: "barmmpoints",
        // 'paint': {
        //     'circle-radius': 6,
        //     'circle-color': '#B42222'
        // },

        paint: {
          "circle-radius": {
            stops: [
              [7, 3],
              [8, 4],
              [9, 5],
              [10, 6],
              [11, 7],
            ],
          },
          "circle-stroke-width": 1,
          "circle-stroke-color": "#222222",

          "circle-color": [
            "match",
            ["get", "actors_affiliation1"],
            1,
            affiliation_code["1"].color,
            2,
            affiliation_code["1"].color,
            3,
            affiliation_code["1"].color,
            4,
            affiliation_code["1"].color,
            5,
            affiliation_code["1"].color,
            6,
            affiliation_code["1"].color,
            7,
            affiliation_code["1"].color,
            8,
            affiliation_code["1"].color,
            9,
            affiliation_code["1"].color,
            10,
            affiliation_code["1"].color,
            11,
            affiliation_code["1"].color,
            12,
            affiliation_code["1"].color,
            13,
            affiliation_code["1"].color,
            14,
            affiliation_code["1"].color,
            15,
            affiliation_code["1"].color,
            16,
            affiliation_code["1"].color,
            19,
            affiliation_code["1"].color,
            20,
            affiliation_code["1"].color,
            21,
            affiliation_code["1"].color,
            22,
            affiliation_code["1"].color,
            23,
            affiliation_code["1"].color,
            24,
            affiliation_code["1"].color,
            25,
            affiliation_code["1"].color,
            26,
            affiliation_code["1"].color,
            27,
            affiliation_code["1"].color,
            28,
            affiliation_code["1"].color,
            29,
            affiliation_code["1"].color,
            30,
            affiliation_code["1"].color,
            31,
            affiliation_code["1"].color,
            32,
            affiliation_code["1"].color,
            33,
            affiliation_code["1"].color,
            34,
            affiliation_code["1"].color,
            35,
            affiliation_code["1"].color,
            36,
            affiliation_code["1"].color,
            37,
            affiliation_code["1"].color,
            -99,
            affiliation_code["1"].color,
            -98,
            affiliation_code["1"].color,
            "#000",
          ],          "circle-opacity": 0.75,
        },
      };

      var provincialFill = {
        id: "provfill",
        type: "fill",
        source: "provSource",
        maxzoom: 9,
        layout: {
          // Make the layer visible by default.
          visibility: "none",
        },
        paint: {
          "fill-color": [
            "interpolate",
            ["linear"],
            ["get", "count"],
            -1,
            "#eeeeee",
            10,
            "#fcbba1",
            500,
            "#fc9272",
            1000,
            "#fb6a4a",
            5000,
            "#de2d26",
            10000,
            "#a50f15",
          ],
          "fill-opacity": 0.75,
        },
      };

      var municipalFill = {
        id: "muncfill",
        type: "fill",
        source: "muncSource",
        minzoom: 9,
        layout: {
          // Make the layer visible by default.
          visibility: "none",
        },
        paint: {
          "fill-color": [
            "interpolate",
            ["linear"],
            ["get", "count"],
            -1,
            "#eeeeee",
            10,
            "#fcbba1",
            500,
            "#fc9272",
            1000,
            "#fb6a4a",
            5000,
            "#de2d26",
            10000,
            "#a50f15",
          ],
          "fill-opacity": 0.75,
        },
      };

      var provincialOutline = {
        id: "provoutline",
        type: "line",
        source: "provSource",
        maxzoom: 9,
        layout: {},
        paint: {
          "line-color": "#222",
          "line-width": 1.5,
        },
      };

      var municipalOutline = {
        id: "muncoutline",
        type: "line",
        source: "muncSource",
        minzoom: 9,
        paint: {
          "line-color": "#222",
          "line-width": 1,
        },
      };

      function filterBySource(year, json_obj) {
        const newGeoJSON = { ...json_obj };
        newGeoJSON.features = json_obj.features.filter(
          (feature) => feature.properties.incyr === years[year]
        );
        map.getSource("barmm").setData(newGeoJSON);
        map.getSource("barmmpoints").setData(newGeoJSON);
      }

      function getSelectValues(select) {
        var result = [];
        var options = select && select.options;
        var opt;

        for (var i = 0, iLen = options.length; i < iLen; i++) {
          opt = options[i];

          if (opt.selected) {
            result.push(opt.value || opt.text);
          }
        }
        return result;
      }

      function filterByPSource(syear, eyear, json_obj) {
        var checked = [];
        var wholeFilter = ["all", ["in", "actors_affiliation1"]];
        for (let index = 1; index <= CATEGORIES; index++) {
          if (document.getElementById("cat" + index).checked)
            wholeFilter[1].push(index);
        }

        var newGeoJSON = { ...json_obj };
        newGeoJSON.features = json_obj.features.filter(
          (feature) =>
            feature.properties.incyr >= syear &&
            feature.properties.incyr <= eyear
        );

        var selectedMonths = getSelectValues(
          document.getElementById("monthSelect")
        );
        newGeoJSON.features = newGeoJSON.features.filter((feature) =>
          selectedMonths.includes(feature.properties.incmo.toString())
        );

        map.getSource("barmmpoints").setData(newGeoJSON);
        // map.setFilter("incpoints", wholeFilter);
      }

      function createProv(syear, eyear, prov_obj, source) {
        const newGeoJSON = { ...prov_obj };
        newGeoJSON.features = prov_obj.features.map((feature) => {
          var count = 0;
          for (let index = syear; index <= eyear; index++) {
            count = count + feature.properties[index];
          }

          feature.properties.count = count;

          return feature;
        });

        map.getSource(source).setData(newGeoJSON);
      }

      function Get(yourUrl) {
        var Httpreq = new XMLHttpRequest(); // a new request
        Httpreq.open("GET", yourUrl, false);
        Httpreq.send(null);
        return Httpreq.responseText;
      }

      map.on("load", function () {
        var json_obj = JSON.parse(
          Get("https://crc2022-dev.online/maps/incidents_new.geojson")
        );
        var prov_obj = JSON.parse(
          Get("https://crc2022-dev.online/maps/prov_poly.geojson")
        );
        var munc_obj = JSON.parse(
          Get("https://crc2022-dev.online/maps/munc_poly.geojson")
        );
        var clus_obj = JSON.parse(
          Get("https://crc2022-dev.online/maps/deaths_prov.geojson")
        );
        var clus2_obj = JSON.parse(
          Get("https://crc2022-dev.online/maps/deaths_munc.geojson")
        );

        filterByMSource(START_YEAR, END_YEAR, clus_obj, clus2_obj);
        // filterByMSource(2011, 2019, munc_obj);

        map.addSource("barmmpoints", {
          type: "geojson",
          data: json_obj,
        });

        map.addLayer(incidentPointsLayer);
        filterByPSource(START_YEAR, END_YEAR, json_obj);

        map.addSource("provSource", {
          type: "geojson",
          data: prov_obj,
        });

        map.addSource("muncSource", {
          type: "geojson",
          data: munc_obj,
        });

        createProv(START_YEAR, END_YEAR, prov_obj, "provSource");
        createProv(START_YEAR, END_YEAR, munc_obj, "muncSource");
        map.addLayer(provincialFill, "bridge-simple");
        map.addLayer(municipalFill, "bridge-simple");
        map.addLayer(provincialOutline, "bridge-simple");
        map.addLayer(municipalOutline, "bridge-simple");

        slider2.noUiSlider.on("slide", function () {
          var startYear = years[Math.round(slider2.noUiSlider.get()[0])];
          var endYear = years[Math.round(slider2.noUiSlider.get()[1])];

          filterByMSource(startYear, endYear, clus_obj, clus2_obj);
          filterByPSource(startYear, endYear, json_obj);
          createProv(startYear, endYear, prov_obj, "provSource");
          createProv(startYear, endYear, munc_obj, "muncSource");

          document.getElementById("year").textContent =
            startYear + " - " + endYear;
          updateMarkers();
          updateMuncMarkers();
        });

        ////////////////////////////

        // objects for caching and keeping track of HTML marker objects (for performance)
        var markers = {};
        var markersOnScreen = {};

        function updateMarkers() {
          var newMarkers = {};
          var features = map.querySourceFeatures("barmm");

          // for every cluster on the screen, create an HTML marker for it (if we haven't yet),
          // and add it to the map if it's not there already
          for (var i = 0; i < features.length; i++) {
            var coords = features[i].geometry.coordinates;
            var props = features[i].properties;
            if (!props.cluster) continue;
            var id = props.cluster_id;

            var marker = markers[id];
            if (!marker) {
              var el = createDonutChart(props);
              marker = markers[id] = new mapboxgl.Marker({
                element: el,
              }).setLngLat(coords);
            }
            newMarkers[id] = marker;

            if (!markersOnScreen[id]) marker.addTo(map);
          }
          // for every marker we've added previously, remove those that are no longer visible
          for (id in markersOnScreen) {
            if (!newMarkers[id]) markersOnScreen[id].remove();
          }
          markersOnScreen = newMarkers;
        }

        var muncmarkers = {};
        var muncmarkersOnScreen = {};

        function updateMuncMarkers() {
          var newmuncMarkers = {};
          var features = map.querySourceFeatures("muncbarmm");

          // for every cluster on the screen, create an HTML marker for it (if we haven't yet),
          // and add it to the map if it's not there already
          for (var i = 0; i < features.length; i++) {
            var coords = features[i].geometry.coordinates;
            var props = features[i].properties;
            if (!props.cluster) continue;
            var id = props.cluster_id;

            var marker = muncmarkers[id];
            if (!marker) {
              var el = createDonutChart(props);
              marker = muncmarkers[id] = new mapboxgl.Marker({
                element: el,
              }).setLngLat(coords);
            }
            newmuncMarkers[id] = marker;

            if (!muncmarkersOnScreen[id]) marker.addTo(map);
          }
          // for every marker we've added previously, remove those that are no longer visible
          for (id in muncmarkersOnScreen) {
            if (!newmuncMarkers[id]) muncmarkersOnScreen[id].remove();
          }
          muncmarkersOnScreen = newmuncMarkers;
        }
        // after the GeoJSON data is loaded, update markers on the screen on every frame

        map.on("render", function () {
          if (!map.isSourceLoaded("barmm")) return;
          updateMarkers();
          updateMuncMarkers();
        });

        function filterByMSource(syear, eyear, clus_obj, clus2_obj) {
          var checked = [];
          for (let index = 1; index <= CATEGORIES; index++) {
            checked[index] = document.getElementById("cat" + index).checked;
          }

          let checker = checked.every((v) => v === false);

          markers = {};
          muncmarkers = {};

          var yearFilter = [
            "all",
            [">=", ["get", "incyr"], syear],
            ["<=", ["get", "incyr"], eyear],
          ];

          var categoryFilter = [];
          for (let index = 1; index <= CATEGORIES; index++) {
            if (checked[index]) {
              categoryFilter[index] = ["get", String(index)];
            } else {
              categoryFilter[index] = 0;
            }
          }

          var newGeoJSON = { ...clus_obj };

          var selectedMonths = getSelectValues(
            document.getElementById("monthSelect")
          );
          newGeoJSON.features = newGeoJSON.features.filter((feature) =>
            selectedMonths.includes(feature.properties.incmo.toString())
          );

          var dispFlag = map.getSource("barmm");

          if (typeof dispFlag !== "undefined") {
            map.removeLayer("clusters");
            map.removeSource("barmm");
            map.removeLayer("muncclusters");
            map.removeSource("muncbarmm");
          }

          map.addSource("barmm", {
            type: "geojson",
            data: newGeoJSON,
            cluster: true,
            clusterRadius: 5,
            clusterProperties: {
              // keep separate counts for each magnitude category in a cluster

              mag1: ["+", ["case", yearFilter, categoryFilter[1], 0]]
            },
          });

          map.addLayer({
            id: "clusters",
            type: "circle",
            source: "barmm",
            maxzoom: CLUSTERZOOMTHRESHOLD,
            filter: [">", ["get", "point_count"], 0],
            paint: {
              "circle-opacity": 0,
            },
          });

          newGeoJSON = { ...clus2_obj };
          console.log(newGeoJSON);
          newGeoJSON.features = newGeoJSON.features.filter((feature) =>
            selectedMonths.includes(feature.properties.incmo.toString())
          );
          map.addSource("muncbarmm", {
            type: "geojson",
            data: newGeoJSON,
            cluster: true,
            clusterRadius: 5,
            clusterProperties: {
              // keep separate counts for each magnitude category in a cluster

              mag1: ["+", ["case", yearFilter, categoryFilter[1], 0]]
            },
          });

          map.addLayer({
            id: "muncclusters",
            type: "circle",
            source: "muncbarmm",
            minzoom: CLUSTERZOOMTHRESHOLD,
            filter: [">", ["get", "point_count"], 0],
            paint: {
              "circle-opacity": 0,
            },
          });
        }

        for (let index = 1; index <= CATEGORIES; index++) {
          checkbox = document.getElementById("cat" + index);
          checkbox.addEventListener("change", (e) => {
            var startYear = years[Math.round(slider2.noUiSlider.get()[0])];
            var endYear = years[Math.round(slider2.noUiSlider.get()[1])];

            filterByMSource(startYear, endYear, clus_obj, clus2_obj);
            filterByPSource(startYear, endYear, json_obj);
            updateMarkers();
            updateMuncMarkers();
          });
        }


        var a = document.getElementById("monthSelect_multiSelect");
        a.addEventListener("change", (event) => {
          var startYear = years[Math.round(slider2.noUiSlider.get()[0])];
          var endYear = years[Math.round(slider2.noUiSlider.get()[1])];

          filterByMSource(startYear, endYear, clus_obj, clus2_obj);
          filterByPSource(startYear, endYear, json_obj);
          updateMarkers();
          updateMuncMarkers();
        });

        for (let index = 1; index <= 3; index++) {
          checkbox = document.getElementById("opt" + index);
          checkbox.addEventListener("change", (e) => {
            switcher();
          });
        }

        function switcher() {
          let layers = [
            [],
            ["incpoints"],
            ["clusters", "muncclusters"],
            ["provfill", "muncfill"],
          ];

          for (let index = 1; index <= 3; index++) {
            let pointFlag = document.getElementById("opt" + index).checked;

            let visibileFlag = pointFlag ? "visible" : "none";

            layers[index].forEach((element) => {
              map.setLayoutProperty(element, "visibility", visibileFlag);
            });
          }
        }
      });

      map.on("click", "incpoints", function (e) {
        var coordinates = e.features[0].geometry.coordinates.slice();
        var year = e.features[0].properties.incyr;
        var cause = e.features[0].properties.incident_causes_code1;
        var province =
          prov_code[e.features[0].properties.province_psgc.toString()];
        var municpality =
          munc_code[e.features[0].properties.city_psgc.toString()];
        var category = e.features[0].properties.cause_category;
        var incident_title = e.features[0].properties.article_incident_title;
        var incday = e.features[0].properties.incday;
        var incmon = month[e.features[0].properties.incmo];
        var affil = e.features[0].properties.actors_affiliation1;
        var effect = e.features[0].properties.actors_effect1;
        var actorsNum = e.features[0].properties.actors_count_number;

        var popuphtml =
          "<strong>Date:</strong> " +
          incmon +
          " " +
          incday +
          ", " +
          year +
          "<br>";
        popuphtml =
          popuphtml + "<strong>Province</strong>: " + province + "<br>";
        popuphtml =
          popuphtml +
          "<strong>City/Municipality</strong>: " +
          municpality +
          "<br><br>";

        popuphtml =
          popuphtml +
          "<strong>Incident Cause</strong>: " +
          specificCause[cause] +
          "<br>";

        popuphtml =
          popuphtml + "<strong>Incident:</strong>: " + incident_title + "<br>";

        popuphtml =
          popuphtml +
          "<strong>Affiliation</strong>: " +
          affiliation_code[affil].name +
          "<br>";

        popuphtml =
          popuphtml +
          "<strong>Number of Actors</strong>: " +
          actorsNum +
          "<br>";

        new mapboxgl.Popup()
          .setLngLat(coordinates)
          .setHTML(popuphtml)
          .addTo(map);
      });
      map.on("mouseenter", "incpoints", function () {
        map.getCanvas().style.cursor = "pointer";
      });

      // Change it back to a pointer when it leaves.
      map.on("mouseleave", "incpoints", function () {
        map.getCanvas().style.cursor = "";
      });

      // code for creating an SVG donut chart from feature properties
      function createDonutChart(props) {
        var offsets = [];
        var counts = [
          props.mag1
        ];

        var total = 0;
        for (var i = 0; i < counts.length; i++) {
          offsets.push(total);
          total += counts[i];
        }

        var fontSize =
          total >= 1000
            ? 22
            : total >= 100
            ? 20
            : total >= 10
            ? 18
            : total >= 1
            ? 16
            : 1;
        var r =
          total >= 10000
            ? 64
            : total >= 1000
            ? 50
            : total >= 100
            ? 32
            : total >= 10
            ? 24
            : total >= 1
            ? 16
            : 1;
        var r0 = Math.round(r * 0.6);
        var w = r * 2;

        var html =
          '<div><svg width="' +
          w +
          '" height="' +
          w +
          '" viewbox="0 0 ' +
          w +
          " " +
          w +
          '" text-anchor="middle" style="font: ' +
          fontSize +
          'px sans-serif; display: block">';

        for (i = 0; i < counts.length; i++) {
          html += donutSegment(
            offsets[i] / total,
            (offsets[i] + counts[i]) / total,
            r,
            r0,
            colors[i]
          );
        }

        let color = "white";
        let totalCount = total;
        if (total === 0) {
          totalCount = "";
          color = "none";
        }
        totalCount = totalCount.toLocaleString();
        html +=
          '<circle cx="' +
          r +
          '" cy="' +
          r +
          '" r="' +
          r0 +
          '" fill="' +
          color +
          '" /><text dominant-baseline="central" transform="translate(' +
          r +
          ", " +
          r +
          ')">' +
          totalCount +
          "</text></svg></div>";

        var el = document.createElement("div");
        el.innerHTML = html;
        return el.firstChild;
      }

      function donutSegment(start, end, r, r0, color) {
        if (end - start === 1) end -= 0.00001;
        var a0 = 2 * Math.PI * (start - 0.25);
        var a1 = 2 * Math.PI * (end - 0.25);
        var x0 = Math.cos(a0),
          y0 = Math.sin(a0);
        var x1 = Math.cos(a1),
          y1 = Math.sin(a1);
        var largeArc = end - start > 0.5 ? 1 : 0;

        return [
          '<path d="M',
          r + r0 * x0,
          r + r0 * y0,
          "L",
          r + r * x0,
          r + r * y0,
          "A",
          r,
          r,
          0,
          largeArc,
          1,
          r + r * x1,
          r + r * y1,
          "L",
          r + r0 * x1,
          r + r0 * y1,
          "A",
          r0,
          r0,
          0,
          largeArc,
          0,
          r + r0 * x0,
          r + r0 * y0,
          '" fill="' + color + '" />',
        ].join(" ");
      }
    </script>
  </body>
</html>
